/*
 Generated by typeshare 1.8.0
 */

import Foundation

public enum Signal: Codable {
	case command(Command)
	case event(Event)

	enum CodingKeys: String, CodingKey, Codable {
		case command = "Command",
			event = "Event"
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, content
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .command:
				if let content = try? container.decode(Command.self, forKey: .content) {
					self = .command(content)
					return
				}
			case .event:
				if let content = try? container.decode(Event.self, forKey: .content) {
					self = .event(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(Signal.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Signal"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .command(let content):
			try container.encode(CodingKeys.command, forKey: .type)
			try container.encode(content, forKey: .content)
		case .event(let content):
			try container.encode(CodingKeys.event, forKey: .type)
			try container.encode(content, forKey: .content)
		}
	}
}

public enum Command: String, Codable {
	case start = "Start"
	case stop = "Stop"
}

public enum Event: String, Codable {
	case started = "Started"
	case stopped = "Stopped"
}
